name: Sync Rules Files

on:
  push:
    paths:
      - rules-list.txt
      - mapping.csv
  schedule:
    - cron: '0 4 * * *'
  workflow_dispatch:

env:
  RULES_LIST: rules-list.txt
  MAPPING_FILE: mapping.csv
  OUTPUT_DIR: rules

jobs:
  sync-rules:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Create output directory if not exists
      run: mkdir -p ${{ env.OUTPUT_DIR }}

    - name: Validate rules-list.txt or mapping.csv exists with valid URLs
      run: |
        if [ ! -f "${{ env.RULES_LIST }}" ] && [ ! -f "${{ env.MAPPING_FILE }}" ]; then
          echo "Error: Neither ${RULES_LIST} nor ${MAPPING_FILE} file exists."
          exit 1
        fi

        if [ -f "${{ env.RULES_LIST }}" ]; then
          valid_rules=$(grep -E '^https?://' "${{ env.RULES_LIST }}" | wc -l)
          if [ "$valid_rules" -eq 0 ]; then
            echo "Warning: ${RULES_LIST} contains no valid URLs."
          fi
        fi

        if [ -f "${{ env.MAPPING_FILE }}" ]; then
          valid_mappings=$(tail -n +2 "${{ env.MAPPING_FILE }}" | cut -d',' -f1 | grep -E '^https?://' | wc -l)
          if [ "$valid_mappings" -eq 0 ]; then
            echo "Warning: ${MAPPING_FILE} contains no valid URLs."
          fi
        fi

        if [ "$valid_rules" -eq 0 ] && [ "$valid_mappings" -eq 0 ]; then
          echo "Error: No valid URLs found in either ${RULES_LIST} or ${MAPPING_FILE}."
          exit 1
        fi

    - name: Print contents of rules-list.txt
      if: ${{ steps.validate_files.outputs.valid_rules_list == 'true' }}
      run: cat "${{ env.RULES_LIST }}"

    - name: Print contents of mapping.csv
      if: ${{ steps.validate_files.outputs.valid_mapping_file == 'true' }}
      run: cat "${{ env.MAPPING_FILE }}"

    - name: Generate or update CSV mapping list
      id: generate_or_update_csv_mapping
      run: |
        > temp_mapping.csv
        echo "URL,Local_Filename,Hash" >> temp_mapping.csv
        declare -A seen_filenames
        declare -A current_hashes

        # Read existing mappings from CSV
        if [ -f "${{ env.MAPPING_FILE }}" ]; then
          tail -n +2 "${{ env.MAPPING_FILE }}" | while IFS=',' read -r url local_filename hash; do
            current_hashes["$url"]=$hash
            seen_filenames["$local_filename"]=$url
          done
        fi

        # Read URLs from rules-list.txt
        if [ -f "${{ env.RULES_LIST }}" ]; then
          while IFS= read -r url; do
            # Skip empty lines or comments
            if [[ -z "$url" || "$url" == \#* ]]; then
              continue
            fi

            # Ensure the URL has the correct protocol
            if [[ ! "$url" =~ ^https?:// ]]; then
              echo "Invalid URL: $url. URLs must start with http:// or https://"
              continue
            fi

            # Extract the last path segment from URL
            filename=$(basename "$url")

            # Determine the final filename to use
            final_filename="$filename"

            # Check if the filename has been seen before
            if [[ -n "${seen_filenames[$final_filename]}" && "${seen_filenames[$final_filename]}" != "$url" ]]; then
              # If a file with the same name exists, generate a new filename using URL's last two segments
              path_segments=($(dirname "$url" | tr '/' '\n'))
              last_segment="${path_segments[-1]}"
              second_last_segment="${path_segments[-2]}"
              base="${second_last_segment}-${last_segment}-${filename}"
              final_filename="$base"
              counter=1

              while [[ -n "${seen_filenames[$final_filename]}" ]]; do
                # Generate unique filename
                extension="${filename##*.}"
                unique_base="${second_last_segment}-${last_segment}-${base%.*}"
                final_filename="${unique_base}-${counter}.${extension}"
                ((counter++))
              done
            fi

            # Mark the filename as seen
            seen_filenames["$final_filename"]=$url

            # Add entry to temp_mapping.csv
            echo "$url,$final_filename,${current_hashes[$url]:-}" >> temp_mapping.csv
          done < "${{ env.RULES_LIST }}"
        fi

        # Move temp_mapping.csv to MAPPING_FILE
        mv temp_mapping.csv "${{ env.MAPPING_FILE }}"

    - name: Print CSV mapping list
      run: cat "${{ env.MAPPING_FILE }}"

    - name: Print URLs to be downloaded
      id: print_urls
      run: |
        echo "URLs to be downloaded:"
        tail -n +2 "${{ env.MAPPING_FILE }}" | while IFS=',' read -r url local_filename hash; do
          echo "URL: $url -> Local Filename: $local_filename -> Hash: $hash"
        done

    - name: Download files based on CSV mapping list
      id: download_files
      run: |
        declare -A seen_hashes

        # Read existing hashes from CSV
        tail -n +2 "${{ env.MAPPING_FILE }}" | while IFS=',' read -r url local_filename hash; do
          seen_hashes["$url"]=$hash
        done

        tail -n +2 "${{ env.MAPPING_FILE }}" | while IFS=',' read -r url local_filename hash; do
          local_file="${{ env.OUTPUT_DIR }}/${local_filename}"

          # Check if the file already exists and is up to date
          if [ -f "$local_file" ]; then
            current_hash=$(sha256sum "$local_file" | awk '{print $1}')
            expected_hash="${seen_hashes[$url]}"

            if [ "$current_hash" == "$expected_hash" ]; then
              echo "$local_filename is already up to date. Skipping download."
              continue
            fi
          fi

          echo "Downloading $url as $local_filename"
          wget --continue -O "$local_file" "$url" || echo "Failed to download $url. Skipping."

          # Calculate new hash after downloading
          if [ -f "$local_file" ]; then
            new_hash=$(sha256sum "$local_file" | awk '{print $1}')
            # Update CSV with new hash
            sed -i "s|^\($url,.*\)$|\1,$new_hash|" "${{ env.MAPPING_FILE }}"
          fi
        done

    - name: List files in rules directory
      run: ls -la "${{ env.OUTPUT_DIR }}"

    - name: Add changes to staging
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git add "${{ env.OUTPUT_DIR }}"
        git add "${{ env.MAPPING_FILE }}"

    - name: Commit changes
      run: |
        git diff-index --quiet HEAD || git commit -m "Update rules files from rules-list.txt"

    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
